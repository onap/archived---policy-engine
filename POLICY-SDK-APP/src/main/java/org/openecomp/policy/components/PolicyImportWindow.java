/*-
 * ============LICENSE_START=======================================================
 * ECOMP Policy Engine
 * ================================================================================
 * Copyright (C) 2017 AT&T Intellectual Property. All rights reserved.
 * ================================================================================
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============LICENSE_END=========================================================
 */

package org.openecomp.policy.components;


import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Set;

import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.apache.commons.io.IOUtils;
import org.openecomp.policy.common.logging.flexlogger.FlexLogger;
import org.openecomp.policy.common.logging.flexlogger.Logger;
import org.openecomp.policy.xacml.api.XACMLErrorConstants;



public class PolicyImportWindow{

	private static final Logger LOGGER	= FlexLogger.getLogger(PolicyImportWindow.class);
	private Path newfile = null;
	private boolean succeeded = false;
	private Boolean superadmin = false;
	private ArrayList<String> xacmlFiles = new ArrayList<String>();
	private static FileOutputStream outputFile;
	/**
	 * The constructor should first build the main layout, set the
	 * composition root and then do any custom initialization.
	 *
	 * The constructor will not be automatically regenerated by the
	 * visual editor.
	 */
	
	public OutputStream receiveUpload(String filename, String mimeType) {

		//
		// Create its new full path
		//
		this.newfile = null;
		//
		// Does it already exist?
		//
		if (Files.exists(this.newfile)) {
			return null;
		}
		//
		// Try to create the output stream
		//
		try {
			return new FileOutputStream(this.newfile.toFile());
		} catch (FileNotFoundException e) {
			LOGGER.error("Failed to create uploaded file", e);
		}
		return null;
	}

	public void Upload(){
		TarArchiveEntry entry = null;
		TarArchiveInputStream extractFile = null;
		try {
			extractFile = new TarArchiveInputStream (new FileInputStream(this.newfile.toFile()));
		} catch (FileNotFoundException e1) {
			e1.printStackTrace();
		}
		//Create a loop to read every single entry in TAR file 
		try {
			while ((entry = extractFile.getNextTarEntry()) != null) {
				this.superadmin = true;
				try{
					copyFileToLocation(extractFile, entry, xacmlFiles, null, superadmin);
				}catch(Exception e){
					LOGGER.error(XACMLErrorConstants.ERROR_SYSTEM_ERROR+"Exception while Importing Polcies"+e);
				}
			}
		} catch (IOException e) {
			LOGGER.error("Exception Occured"+e);
		}

	}

	//Copy files to Directorys 
	public static void copyFileToLocation(TarArchiveInputStream extractFile, TarArchiveEntry entry, ArrayList<String> xacmlFiles, Set<String> finalScopes, Boolean superadminValue ) throws IOException{
		String individualFiles = "";
		int offset = 0;
		outputFile = null;
		// Get the name of the file
		if(superadminValue){
			individualFiles = entry.getName();
		}else{
			for(int i =0; i< finalScopes.size(); i++){
				if(entry.getName().startsWith(finalScopes.toArray()[i].toString())){
					individualFiles = entry.getName();
				}
			}		
		}

		if(individualFiles.endsWith(".xls")){
			if(individualFiles.contains("\\")){
				individualFiles = individualFiles.replace("\\", File.separator);
			}else if(individualFiles.contains("/")){
				individualFiles = individualFiles.replace("/", File.separator);
			}
			return;
		}

		individualFiles = individualFiles.replace("/", File.separator);
		individualFiles = individualFiles.replace("\\", File.separator);

		//Create the path with the entry name 
		


		// Get Size of the file and create a byte array for the size 
		byte[] content = new byte[(int) entry.getSize()];

		offset=0;
		LOGGER.info("Size of the File is: " + entry.getSize());                  
		// Read file from the archive into byte array 
		extractFile.read(content, offset, content.length - offset);
		
		// Use IOUtiles to write content of byte array to physical file 
		IOUtils.write(content,outputFile); 

		// Close Output Stream 
		try {
			outputFile.close();
		} catch (IOException e) {
			LOGGER.info("IOException:" +e);
			LOGGER.error("Exception Occured"+e);
		}
	}


	public Path	getUploadedFile() {
		if (this.succeeded) {
			return this.newfile;
		}
		return null;
	}

}
